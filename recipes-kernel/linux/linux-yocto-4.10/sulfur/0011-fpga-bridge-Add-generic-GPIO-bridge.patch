From e586898e9774ea7fa0c262f687ef2b5f3b707313 Mon Sep 17 00:00:00 2001
From: Moritz Fischer <moritz.fischer@ettus.com>
Date: Wed, 22 Mar 2017 14:34:09 -0700
Subject: [PATCH 11/24] fpga: bridge: Add generic GPIO bridge.

Signed-off-by: Moritz Fischer <moritz.fischer@ettus.com>
---
 drivers/fpga/Kconfig            |   9 ++++
 drivers/fpga/Makefile           |   1 +
 drivers/fpga/fpga-bridge-gpio.c | 101 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 111 insertions(+)
 create mode 100644 drivers/fpga/fpga-bridge-gpio.c

diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
index dee470f..5f118dd 100644
--- a/drivers/fpga/Kconfig
+++ b/drivers/fpga/Kconfig
@@ -76,6 +76,15 @@ config ALTERA_FREEZE_BRIDGE
 	  isolate one region of the FPGA from the busses while that
 	  region is being reprogrammed.
 
+config GPIO_FPGA_BRIDGE
+	tristate "Generic GPIO FPGA PR Bridge"
+	depends on FPGA_BRIDGE
+	help
+	  Say Y to enable drivers for Generic GPIO FPGA PR bridges.
+	  The PR Bridge exists in the FPGA fabric to isolate one
+	  region of the FPGA from the busses while that region is
+	  being reprogrammed during partial reconfig.
+
 endif # FPGA
 
 endmenu
diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
index a5ee3ff..9a9b691 100644
--- a/drivers/fpga/Makefile
+++ b/drivers/fpga/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_FPGA_MGR_ZYNQ_FPGA)	+= zynq-fpga.o
 obj-$(CONFIG_FPGA_BRIDGE)		+= fpga-bridge.o
 obj-$(CONFIG_SOCFPGA_FPGA_BRIDGE)	+= altera-hps2fpga.o altera-fpga2sdram.o
 obj-$(CONFIG_ALTERA_FREEZE_BRIDGE)	+= altera-freeze-bridge.o
+obj-$(CONFIG_GPIO_FPGA_BRIDGE)		+= fpga-bridge-gpio.o
 
 # High Level Interfaces
 obj-$(CONFIG_FPGA_REGION)		+= fpga-region.o
diff --git a/drivers/fpga/fpga-bridge-gpio.c b/drivers/fpga/fpga-bridge-gpio.c
new file mode 100644
index 0000000..967675e
--- /dev/null
+++ b/drivers/fpga/fpga-bridge-gpio.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2017, National Instruments Corp.
+ *
+ * Generic FPGA Bridge Driver using GPIOs to drive the bridge status
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fpga/fpga-bridge.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+struct gpio_bridge_priv {
+	struct gpio_desc *decouple;
+	struct gpio_desc *status;
+};
+
+static int gpio_bridge_enable_show(struct fpga_bridge *bridge)
+{
+	struct gpio_bridge_priv *priv = bridge->priv;
+
+	return !gpiod_get_value(priv->status);
+}
+
+static int gpio_bridge_enable_set(struct fpga_bridge *bridge, bool enable)
+{
+	struct gpio_bridge_priv *priv = bridge->priv;
+
+	gpiod_set_value(priv->decouple, enable);
+
+	return 0;
+}
+
+static const struct fpga_bridge_ops gpio_br_ops = {
+	.enable_set = gpio_bridge_enable_set,
+	.enable_show = gpio_bridge_enable_show,
+};
+
+static const struct of_device_id gpio_bridge_of_match[] = {
+	{ .compatible = "fpga-gpio-bridge", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gpio_bridge_of_match);
+
+static int gpio_bridge_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct gpio_bridge_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->decouple = devm_gpiod_get(dev, "decouple", GPIOD_OUT_LOW);
+	if (IS_ERR(priv->decouple)) {
+		ret = PTR_ERR(priv->decouple);
+		dev_err(dev, "Failed to get 'decouple' GPIO: %d\n", ret);
+		return ret;
+	}
+
+	priv->status = devm_gpiod_get(dev, "decouple_status", GPIOD_IN);
+	if (IS_ERR(priv->status)) {
+		ret = PTR_ERR(priv->status);
+		dev_err(dev, "Failed to get 'decouple_status' GPIO: %d\n", ret);
+		return ret;
+	}
+
+	return fpga_bridge_register(dev, "Generic (GPIO) FPGA bridge",
+				    &gpio_br_ops, priv);
+}
+
+static int gpio_bridge_remove(struct platform_device *pdev)
+{
+	fpga_bridge_unregister(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver gpio_bridge_driver = {
+	.probe = gpio_bridge_probe,
+	.remove = gpio_bridge_remove,
+	.driver = {
+		.name = "gpio_fpga_bridge",
+		.of_match_table = of_match_ptr(gpio_bridge_of_match),
+	},
+};
+module_platform_driver(gpio_bridge_driver);
+
+MODULE_DESCRIPTION("Generic GPIO FPGA Bridge Driver");
+MODULE_AUTHOR("Moritz Fischer <mdf@kernel.org>");
+MODULE_LICENSE("GPL v2");
-- 
2.7.4

